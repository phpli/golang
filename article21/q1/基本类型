string

bool

int8、uint8（byte）（无符号）、int16、uint16、int32（rune）、uint32、int64、uint64、int、uint、uintptr。
float32、float64。
complex64、complex128。

指针类型 - 类C指针
结构体类型 - 类C结构体
函数类型 - 函数类型在Go中是一种一等公民类别
容器类型，包括:
数组类型 - 定长容器类型
切片类型 - 动态长度和容量容器类型
映射类型（map）- 也常称为字典类型。在标准编译器中映射是使用哈希表实现的。
通道类型 - 通道用来同步并发的协程
接口类型 - 接口在反射和多态中发挥着重要角色

*T 指针类型
[5]T 数组类型 //一个元素类型为T、元素个数为5的数组类型
[]T //一个元素类型为T的切片类型
map[Key]T // 一个键值类型为Tkey、元素类型为T的映射类型
struct {
    name string
    age int
}

// 一个函数类型
func(int) (bool, string)

// 一个接口类型
interface {
	Method0(string) int
	Method1() (int, bool)
}

// 几个通道类型
chan T //双向通道
chan<- T //接收通道
<-chan T // 发送通道

type (
	Name = string
	Age  = int
)

Name是内置类型string的一个别名

baseContainer[0 : len(baseContainer)]
baseContainer[: len(baseContainer)]
baseContainer[0 :]
baseContainer[:]
baseContainer[0 : len(baseContainer) : cap(baseContainer)]
baseContainer[: len(baseContainer) : cap(baseContainer)]

//创建切片
make(int[],长度，容量)

遍历映射是随机的
一些关于遍历映射条目的细节：
映射中的条目的遍历顺序是不确定的（可以认为是随机的）。或者说，同一个映射中的条目的两次遍历中，条目的顺序很可能是不一致的，即使在这两次遍历之间，此映射并未发生任何改变。
如果在一个映射中的条目的遍历过程中，一个还没有被遍历到的条目被删除了，则此条目保证不会被遍历出来。
如果在一个映射中的条目的遍历过程中，一个新的条目被添加入此映射，则此条目并不保证将在此遍历过程中被遍历出来。（哈哈哈哈）
baseContainer[low : high : cap(baseContainer)]

// 双下标形式
0 <= low <= high <= cap(baseContainer)

0 <= low <= high <= max <= cap(baseContainer)

字符串值（和布尔以及各种数值类型的值）可以被用做常量。
Go支持两种风格的字符串字面量表示形式：双引号风格（解释型字面表示）和反引号风格（直白字面表示）。具体介绍请阅读前文。
字符串类型的零值为空字符串。一个空字符串在字面上可以用""或者``来表示。
我们可以用运算符+和+=来衔接字符串。
字符串类型都是可比较类型。同一个字符串类型的值可以用==和!=比较运算符来比较。
并且和整数/浮点数一样，同一个字符串类型的值也可以用>、<、>=和<=比较运算符来比较。
当比较两个字符串值的时候，它们的底层字节将逐一进行比较。
如果一个字符串是另一个字符串的前缀，并且另一个字符串较长，则另一个字符串为两者中的较大者。

和Java语言一样，字符串值的内容（即底层字节）是不可更改的。 字符串值的长度也是不可独立被更改的。
一个可寻址的字符串只能通过将另一个字符串赋值给它来整体修改它。
在常量和变量一文中，我们已经了解到整数可以被显式转换为字符串类型（但是反之不行）。



值类型的数据，默认全部都是深复制，Array、Int、String、Struct、Float，Bool。
引用类型的数据，默认全部都是浅复制，Slice，Map。
所以请尽量避免比较两个很长的不共享底层字节序列的相等的（或者几乎相等的）字符串。

参数列表必须用一对小括号()括起来，即使此列表为空。
如果一个函数类型一个结果列表为空，则它可以在函数类型的字面形式中被省略掉。
当一个结果列表含有最多一个结果，则此结果列表的字面形式在它不包含结果名称的时候可以不用括号()括起来。

// 这三个函数类型字面形式是等价的。
func () (x int)
func () (int)
func () int

// 这两个函数类型字面形式是等价的。
func (a int, b string) ()
func (a int, b string)

所有的函数类型都属于不可比较类型,但是，和映射值以及切片值类似，一个函数值可以和类型不确定的nil比较。
因为函数类型属于不可比较类型，所以函数类型不可用做映射类型的键值类型。
package main


所有的函数调用的传参均属于值复制
// 这两个函数的声明见前面几例。
func Sum(values ...int64) (sum int64) {......}
func Concat(sep string, tokens ...string) string {......}

func main() {
	// 下面两行报同样的错：实参数目太多了。
	_ = Sum(2, []int64{3, 5}...)
	_ = Concat(",", "Go", []string{"C", "Rust"}...)
}

对于每一个为值类型属主显式声明的方法，同时将有一个隐式方法和两个隐式函数被自动声明。
例如：
type Book struct {
	pages int
}

func (b Book) Pages() int {
	return Book.pages(b)
}
func (b *Book) Pages() int {
	return Book.Pages(*b) // 调用上节中隐式声明的函数
}
func (b *Book) SetPages(pages int) {
	b.pages = pages
}

请注意：不同代码包中的同名非导出方法将总被认为是不同名的。

下列类型的方法集总为空：
内置基本类型；
定义的指针类型；
基类型为指针类型或者接口类型的指针类型；
非定义的数组/切片/映射/函数/通道类型。

demo86.go 中的最后一行
上例中的(&book).SetPages(123)一行为什么可以被简化为book.SetPages(123)呢？
毕竟，类型Book并不拥有一个SetPages方法。
啊哈，这可以看作是Go中为了让代码看上去更简洁而特别设计的语法糖。此语法糖只对可寻址的值类型的属主有效。
编译器会自动将book.SetPages(123)改写为(&book).SetPages(123)。
但另一方面，我们应该总是认为aBookExpression.SetPages是一个合法的选择器（从语法层面讲），
即使表达式aBookExpression被估值为一个不可寻址的Book值（在这种情况下，aBookExpression.SetPages是一个无效但合法的选择器）。

和普通参数传参一样，属主参数的传参也是一个值复制过程。 所以，在方法体内对属主参数的直接部分的修改将不会反映到方法体外。

事实上，我们总可以在方法声明中使用指针类型属主而不会产生任何逻辑问题。 我们仅仅是为了程序效率考虑有时候才会在函数声明中使用值类型属主

对于值类型属主还是指针类型属主都可以接受的方法声明，下面列出了一些考虑因素：
太多的指针可能会增加垃圾回收器的负担。
如果一个值类型的尺寸太大，那么属主参数在传参的时候的复制成本将不可忽略。 指针类型都是小尺寸类型。 关于各种不同类型的尺寸，请阅读值复制代价一文。
在并发场合下，同时调用值类型属主和指针类型属主方法比较易于产生数据竞争。
sync标准库包中的类型的值不应该被复制，所以如果一个结构体类型内嵌了这些类型，则不应该为这个结构体类型声明值类型属主的方法。
