string

bool

int8、uint8（byte）（无符号）、int16、uint16、int32（rune）、uint32、int64、uint64、int、uint、uintptr。
float32、float64。
complex64、complex128。

指针类型 - 类C指针
结构体类型 - 类C结构体
函数类型 - 函数类型在Go中是一种一等公民类别
容器类型，包括:
数组类型 - 定长容器类型
切片类型 - 动态长度和容量容器类型
映射类型（map）- 也常称为字典类型。在标准编译器中映射是使用哈希表实现的。
通道类型 - 通道用来同步并发的协程
接口类型 - 接口在反射和多态中发挥着重要角色

*T 指针类型
[5]T 数组类型 //一个元素类型为T、元素个数为5的数组类型
[]T //一个元素类型为T的切片类型
map[Key]T // 一个键值类型为Tkey、元素类型为T的映射类型
struct {
    name string
    age int
}

// 一个函数类型
func(int) (bool, string)

// 一个接口类型
interface {
	Method0(string) int
	Method1() (int, bool)
}

// 几个通道类型
chan T //双向通道
chan<- T //接收通道
<-chan T // 发送通道

type (
	Name = string
	Age  = int
)

Name是内置类型string的一个别名

baseContainer[0 : len(baseContainer)]
baseContainer[: len(baseContainer)]
baseContainer[0 :]
baseContainer[:]
baseContainer[0 : len(baseContainer) : cap(baseContainer)]
baseContainer[: len(baseContainer) : cap(baseContainer)]

//创建切片
make(int[],长度，容量)

遍历映射是随机的
一些关于遍历映射条目的细节：
映射中的条目的遍历顺序是不确定的（可以认为是随机的）。或者说，同一个映射中的条目的两次遍历中，条目的顺序很可能是不一致的，即使在这两次遍历之间，此映射并未发生任何改变。
如果在一个映射中的条目的遍历过程中，一个还没有被遍历到的条目被删除了，则此条目保证不会被遍历出来。
如果在一个映射中的条目的遍历过程中，一个新的条目被添加入此映射，则此条目并不保证将在此遍历过程中被遍历出来。（哈哈哈哈）
baseContainer[low : high : cap(baseContainer)]

// 双下标形式
0 <= low <= high <= cap(baseContainer)

0 <= low <= high <= max <= cap(baseContainer)

字符串值（和布尔以及各种数值类型的值）可以被用做常量。
Go支持两种风格的字符串字面量表示形式：双引号风格（解释型字面表示）和反引号风格（直白字面表示）。具体介绍请阅读前文。
字符串类型的零值为空字符串。一个空字符串在字面上可以用""或者``来表示。
我们可以用运算符+和+=来衔接字符串。
字符串类型都是可比较类型。同一个字符串类型的值可以用==和!=比较运算符来比较。
并且和整数/浮点数一样，同一个字符串类型的值也可以用>、<、>=和<=比较运算符来比较。
当比较两个字符串值的时候，它们的底层字节将逐一进行比较。
如果一个字符串是另一个字符串的前缀，并且另一个字符串较长，则另一个字符串为两者中的较大者。

和Java语言一样，字符串值的内容（即底层字节）是不可更改的。 字符串值的长度也是不可独立被更改的。
一个可寻址的字符串只能通过将另一个字符串赋值给它来整体修改它。
在常量和变量一文中，我们已经了解到整数可以被显式转换为字符串类型（但是反之不行）。



值类型的数据，默认全部都是深复制，Array、Int、String、Struct、Float，Bool。
引用类型的数据，默认全部都是浅复制，Slice，Map。
所以请尽量避免比较两个很长的不共享底层字节序列的相等的（或者几乎相等的）字符串。

参数列表必须用一对小括号()括起来，即使此列表为空。
如果一个函数类型一个结果列表为空，则它可以在函数类型的字面形式中被省略掉。
当一个结果列表含有最多一个结果，则此结果列表的字面形式在它不包含结果名称的时候可以不用括号()括起来。

// 这三个函数类型字面形式是等价的。
func () (x int)
func () (int)
func () int

// 这两个函数类型字面形式是等价的。
func (a int, b string) ()
func (a int, b string)

所有的函数类型都属于不可比较类型,但是，和映射值以及切片值类似，一个函数值可以和类型不确定的nil比较。
因为函数类型属于不可比较类型，所以函数类型不可用做映射类型的键值类型。
package main


所有的函数调用的传参均属于值复制
// 这两个函数的声明见前面几例。
func Sum(values ...int64) (sum int64) {......}
func Concat(sep string, tokens ...string) string {......}

func main() {
	// 下面两行报同样的错：实参数目太多了。
	_ = Sum(2, []int64{3, 5}...)
	_ = Concat(",", "Go", []string{"C", "Rust"}...)
}

对于每一个为值类型属主显式声明的方法，同时将有一个隐式方法和两个隐式函数被自动声明。
例如：
type Book struct {
	pages int
}

func (b Book) Pages() int {
	return Book.pages(b)
}
func (b *Book) Pages() int {
	return Book.Pages(*b) // 调用上节中隐式声明的函数
}
func (b *Book) SetPages(pages int) {
	b.pages = pages
}

请注意：不同代码包中的同名非导出方法将总被认为是不同名的。

下列类型的方法集总为空：
内置基本类型；
定义的指针类型；
基类型为指针类型或者接口类型的指针类型；
非定义的数组/切片/映射/函数/通道类型。

demo86.go 中的最后一行
上例中的(&book).SetPages(123)一行为什么可以被简化为book.SetPages(123)呢？
毕竟，类型Book并不拥有一个SetPages方法。
啊哈，这可以看作是Go中为了让代码看上去更简洁而特别设计的语法糖。此语法糖只对可寻址的值类型的属主有效。
编译器会自动将book.SetPages(123)改写为(&book).SetPages(123)。
但另一方面，我们应该总是认为aBookExpression.SetPages是一个合法的选择器（从语法层面讲），
即使表达式aBookExpression被估值为一个不可寻址的Book值（在这种情况下，aBookExpression.SetPages是一个无效但合法的选择器）。

和普通参数传参一样，属主参数的传参也是一个值复制过程。 所以，在方法体内对属主参数的直接部分的修改将不会反映到方法体外。

事实上，我们总可以在方法声明中使用指针类型属主而不会产生任何逻辑问题。 我们仅仅是为了程序效率考虑有时候才会在函数声明中使用值类型属主

对于值类型属主还是指针类型属主都可以接受的方法声明，下面列出了一些考虑因素：
太多的指针可能会增加垃圾回收器的负担。
如果一个值类型的尺寸太大，那么属主参数在传参的时候的复制成本将不可忽略。 指针类型都是小尺寸类型。 关于各种不同类型的尺寸，请阅读值复制代价一文。
在并发场合下，同时调用值类型属主和指针类型属主方法比较易于产生数据竞争。
sync标准库包中的类型的值不应该被复制，所以如果一个结构体类型内嵌了这些类型，则不应该为这个结构体类型声明值类型属主的方法。

接口类型中指定的任何方法原型中的方法名称都不能为空标识符_。
如果两个非定义接口类型指定的方法集是等价的，则这两个接口类型为同一个类型。 但是请注意：不同代码包中的同名非导出方法名将总被认为是不同名的。
注意：因为任何方法集都是一个空方法集的超集，所以任何类型都实现了任何空接口类型。 这是Go中的一个重要事实。
一个包裹了一个nil非接口值的接口值不是一个nil接口值，因为它并非什么都没包裹。

哪些类型可以被内嵌？
一个类型名T只有在它既不表示一个定义的指针类型也不表示一个基类型为指针类型或者接口类型的指针类型的情况下才可以被用作内嵌字段。
一个指针类型*T只有在T为一个类型名并且T既不表示一个指针类型也不表示一个接口类型的时候才能被用作内嵌字段。

类型内嵌的主要目的是为了将被内嵌类型的功能扩展到内嵌它的结构体类型中，从而我们不必再为此结构体类型重复实现被内嵌类型的功能。


动态类型信息是实现反射的关键。
方法表是实现多态的关键。

事实上，对于一个动态类型为T的接口值i，方法调用i.m(...)等价于i.(T).m(...)。

简而言之，两个接口值的比较结果只有在下面两种任一情况下才为true：
这两个接口值都为nil接口值。

这两个接口值的动态类型相同、动态类型为可比较类型、并且动态值相等。
其他情况为false


下面是（使用==比较运算符）比较两个接口值的步骤：
如果其中一个接口值是一个nil接口值，则比较结果为另一个接口值是否也为一个nil接口值。
如果这两个接口值的动态类型不一样，则比较结果为false。
对于这两个接口值的动态类型一样的情形，
如果它们的动态类型为一个不可比较类型，则将产生一个恐慌。
否则，比较结果为它们的动态值的比较结果。

类型嵌套
必须满足以下：
一个类型名T只有在它既不表示一个定义的指针类型也不表示一个基类型为指针类型或者接口类型的指针类型的情况下才可以被用作内嵌字段。
一个指针类型*T只有在T为一个类型名并且T既不表示一个指针类型也不表示一个接口类型的时候才能被用作内嵌字段。


type Encoder interface {Encode([]byte) []byte}
type Person struct {name string; age int}
type Alias = struct {name string; age int}
type AliasPtr = *struct {name string; age int}
type IntPtr *int
type AliasPP = *IntPtr

// 这些类型或别名都可以被内嵌。
Encoder
Person
*Person
Alias
*Alias
AliasPtr
int
*int

// 这些类型或别名都不能被内嵌。
AliasPP          // 基类型为一个指针类型
*Encoder         // 基类型为一个接口类型
*AliasPtr        // 基类型为一个指针类型
IntPtr           // 定义的指针类型
*IntPtr          // 基类型为一个指针类型
*chan int        // 基类型为一个非定义类型
struct {age int} // 非定义非指针类型
map[string]int   // 非定义非指针类型
[]int64          // 非定义非指针类型
func()           // 非定义非指针类型


一个类型安全指针值可以被显式转换为一个非类型安全指针类型，反之亦然。
一个uintptr值可以被显式转换为一个非类型安全指针类型，反之亦然。 但是，注意，一个nil非类型安全指针类型不应该被转换为uintptr并进行算术运算后再转换回来。

在开始介绍合法的非类型安全指针使用模式之前，我们需要知道一些事实。
事实一：非类型安全指针值是指针但uintptr值是整数
事实二：不再被使用的内存块的回收时间点是不确定的
事实三：一个值的地址在程序运行中可能改变
事实四：一个值的生命范围可能并没有代码中看上去的大
事实五：*unsafe.Pointer是一个类型安全指针类型


什么时候需要开辟内存块？
在Go中，在下列场合（不限于）将发生开辟内存块的操作：
显式地调用new和make内置函数。 一个new函数调用总是只开辟一个内存块。 一个make函数调用有可能会开辟多个内存块来承载创建的切片/映射/通道值的直接和底层间接值部。
使用字面量创建映射、切片或函数值。在此创建过程中，一个或多个内存块将被开辟出来。
声明变量。
将一个非接口值赋给一个接口值。（对于标准编译器来说，不包括将一个指针值赋给一个接口值的情况。）
衔接非常量字符串。
将字符串转换为字节切片或者码点切片，或者反之，除了一些编译器优化情形。
将一个整数转换为字符串。
调用内置append函数并且基础切片的容量不足够大。
向一个映射添加一个键值条目并且此映射底层内部的哈希表需要改变容量

事实上，栈对于Go程序来说并非必要。Go程序中所有的内存块都可以开辟在堆上。 支持栈只是为了让Go程序的运行效率更高。
从栈上开辟内存块比在堆上快得多；
开辟在栈上的内存块不需要被垃圾回收；
开辟在栈上的内存块对CPU缓存更加友好。


内存块的一些事实：
如果一个结构体值的一个字段逃逸到了堆上，则此整个结构体值也逃逸到了堆上。
如果一个数组的某个元素逃逸到了堆上，则此整个数组也逃逸到了堆上。
如果一个切片的某个元素逃逸到了堆上，则此切片中的所有元素都将逃逸到堆上，但此切片值的直接部分可能开辟在栈上。
如果一个值部v被一个逃逸到了堆上的值部所引用，则此值部v也将逃逸到堆上。

内存块开辟在什么内存上
内存块可以被开辟在栈上。开辟在一个协程维护的栈上的内存块只能在此协程内部被使用（引用）。
 其它协程是无法访问到这些内存块的。 一个协程可以无需使用任何数据同步技术而使用开辟在它的栈上的内存块上的值部。

堆（heap）是一个虚拟的概念。每个程序只有一个堆。
一般地，如果一个内存块没有开辟在任何一个栈上，则我们说它开辟在了堆上。
开辟在堆上的内存块可以被多个协程并发地访问。 在需要的时候，对承载在它们之上的值部的访问需要做同步。


对于使用标准编译器编译的Go程序，一轮新的垃圾回收过程开启的默认条件是通过GOGC环境变量来控制的。
当从上一轮垃圾回收结束后新申请的内存块的内存总和占上一轮垃圾回收结束时仍在被使用的所有内存块的内存总和的百分比超过此值时，
新的一轮垃圾回收过程将开始。 所以此值决定了垃圾回收过程的频率。 此环境变量的默认值为100。
此值也可以通过调用runtime/debug.SetGCPercent函数在运行时刻被动态地修改。
调用debug.SetGCPercent(-1)将关闭自动垃圾回收。

非安全指针用处之一
在下面这个例子中，我们使用此模式将一个[]MyString值和一个[]string值转换为对方的类型。
 结果切片和被转换的切片将共享底层元素。（这样的转换是不可能通过安全的方式来实现的。）


 如何正确地使用非类型安全指针？

 使用模式一：将类型*T1的一个值转换为非类型安全指针值，然后将此非类型安全指针值转换为类型*T2。
 使用模式二：将一个非类型安全指针值转换为一个uintptr值，然后使用此uintptr值。
 使用模式三：将一个非类型安全指针转换为一个uintptr值，然后此uintptr值参与各种算术运算，再将算术运算的结果uintptr值转回非类型安全指针。(转换前后的非类型安全指针必须指向同一个内存块。)
 使用模式四：将非类型安全指针值转换为uintptr值并传递给syscall.Syscall函数调用。
 通过对上一个使用模式的解释，我们知道像下面这样含有uintptr类型的参数的函数定义是危险的。
 // 假设此函数不会被内联。
 func DoSomething(addr uintptr) {
 	// 对处于传递进来的地址处的值进行读写...
 }

那么此函数是如何保证处于传递给它的地址参数值a1、a2和a3处的内存块在此函数执行过程中一定没有被回收和被移动呢？
此函数无法做出这样的保证。事实上，是编译器做出了这样的保证。 这是syscall.Syscall这样的函数的特权。其它自定义函数无法享受到这样的待遇。
使用模式五：将reflect.Value.Pointer或者reflect.Value.UnsafeAddr方法的uintptr返回值立即转换为非类型安全指针。
(就是尽量不分开写)
比如，下面这个调用是安全的：
p := (*int)(unsafe.Pointer(reflect.ValueOf(new(int)).Pointer()))
而下面这个调用是危险的：
u := reflect.ValueOf(new(int)).Pointer()
// 在这个时刻，处于存储在u中的地址处的内存块
// 可能会被回收掉。
p := (*int)(unsafe.Pointer(u))
使用模式六：将一个reflect.SliceHeader或者reflect.StringHeader值的Data字段转换为非类型安全指针，以及其逆转换。
